import PptxGenJS from "pptxgenjs";
import { getTheme } from "./theme";
import type { SlideContent, GenerateSettings } from "@/lib/types";

// `LAYOUT_WIDE` is 13.333" Ã— 7.5" (16:9 widescreen).
const SLIDE_W = 13.333;
const SLIDE_H = 7.5;
const MARGIN = 1.0;

function transparencyFromOpacity(opacity: number): number {
  const clamped = Math.min(1, Math.max(0, opacity));
  return Math.round((1 - clamped) * 100);
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const cleaned = hex.replace("#", "");
  const value = cleaned.length === 3
    ? cleaned
        .split("")
        .map((c) => c + c)
        .join("")
    : cleaned;
  const n = parseInt(value, 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

function rgbToHex({ r, g, b }: { r: number; g: number; b: number }): string {
  const to = (v: number) => v.toString(16).padStart(2, "0").toUpperCase();
  return `${to(r)}${to(g)}${to(b)}`;
}

function mixHex(a: string, b: string, t: number): string {
  const ra = hexToRgb(a);
  const rb = hexToRgb(b);
  const clamp = Math.min(1, Math.max(0, t));
  return rgbToHex({
    r: Math.round(ra.r + (rb.r - ra.r) * clamp),
    g: Math.round(ra.g + (rb.g - ra.g) * clamp),
    b: Math.round(ra.b + (rb.b - ra.b) * clamp),
  });
}

function addBandedGradient(
  slide: PptxGenJS.Slide,
  color1: string,
  color2: string,
) {
  const bands = [
    { y: 0, h: SLIDE_H * 0.42, c: color1 },
    { y: SLIDE_H * 0.32, h: SLIDE_H * 0.42, c: mixHex(color1, color2, 0.35) },
    { y: SLIDE_H * 0.58, h: SLIDE_H * 0.42, c: mixHex(color1, color2, 0.7) },
    { y: SLIDE_H * 0.78, h: SLIDE_H * 0.5, c: color2 },
  ];

  for (const band of bands) {
    slide.addShape("rect" as unknown as PptxGenJS.ShapeType, {
      x: 0,
      y: band.y,
      w: SLIDE_W,
      h: band.h,
      fill: { color: band.c },
      line: { color: band.c, transparency: 100 },
    });
  }
}

function addAccentGlow(slide: PptxGenJS.Slide, accentColor: string) {
  slide.addShape("ellipse" as unknown as PptxGenJS.ShapeType, {
    x: SLIDE_W * 0.22,
    y: -SLIDE_H * 0.22,
    w: SLIDE_W * 0.56,
    h: SLIDE_H * 0.75,
    fill: { color: accentColor, transparency: 88 },
    line: { color: accentColor, transparency: 100 },
  });
}

function lyricsFontSize(base: number, linesPerSlide: 2 | 3 | 4): number {
  if (linesPerSlide === 2) return base + 6;
  if (linesPerSlide === 4) return base - 4;
  return base;
}

export async function buildPptx(
  slides: SlideContent[],
  settings: GenerateSettings,
): Promise<Buffer> {
  const pres = new PptxGenJS();
  pres.layout = "LAYOUT_WIDE";

  const theme = getTheme(settings.theme);

  for (const sc of slides) {
    const slide = pres.addSlide();

    // Background
    if (sc.type === "lyrics" && settings.backgroundImage) {
      slide.background = { data: settings.backgroundImage };
    } else {
      slide.background = { color: theme.bgGradient.color1 };
      addBandedGradient(slide, theme.bgGradient.color1, theme.bgGradient.color2);
      if (settings.theme === "dark") addAccentGlow(slide, theme.accentColor);
    }

    switch (sc.type) {
      case "cover":
        slide.addText(sc.title ?? "Worship Set", {
          x: MARGIN,
          y: SLIDE_H * 0.33,
          w: SLIDE_W - MARGIN * 2,
          h: 1,
          fontSize: theme.titleFontSize,
          fontFace: theme.fontFace,
          color: theme.textColor,
          align: "center",
          bold: true,
        });
        if (sc.date) {
          slide.addText(sc.date, {
            x: MARGIN,
            y: SLIDE_H * 0.33 + 1.15,
            w: SLIDE_W - MARGIN * 2,
            h: 0.5,
            fontSize: theme.subtitleFontSize,
            fontFace: theme.fontFace,
            color: theme.subtitleColor,
            align: "center",
          });
        }
        slide.addText("Generated by Worshippy", {
          x: MARGIN,
          y: SLIDE_H - MARGIN - 0.4,
          w: SLIDE_W - MARGIN * 2,
          h: 0.35,
          fontSize: 12,
          fontFace: theme.fontFace,
          color: theme.subtitleColor,
          align: "center",
        });
        break;

      case "title":
        slide.addText(sc.title ?? "", {
          x: MARGIN,
          y: SLIDE_H * 0.35,
          w: SLIDE_W - MARGIN * 2,
          h: 1,
          fontSize: theme.titleFontSize,
          fontFace: theme.fontFace,
          color: theme.textColor,
          align: "center",
          bold: true,
        });
        if (sc.artist) {
          slide.addText(sc.artist, {
            x: MARGIN,
            y: SLIDE_H * 0.35 + 1.15,
            w: SLIDE_W - MARGIN * 2,
            h: 0.5,
            fontSize: theme.subtitleFontSize,
            fontFace: theme.fontFace,
            color: theme.subtitleColor,
            align: "center",
          });
        }
        slide.addShape("rect" as unknown as PptxGenJS.ShapeType, {
          x: SLIDE_W * 0.42,
          y: SLIDE_H * 0.35 + 2.0,
          w: SLIDE_W * 0.16,
          h: 0.05,
          fill: { color: theme.accentColor, transparency: 15 },
          line: { color: theme.accentColor, transparency: 100 },
        });
        break;

      case "lyrics": {
        const panelX = MARGIN;
        const panelY = MARGIN * 0.9;
        const panelW = SLIDE_W - MARGIN * 2;
        const panelH = SLIDE_H - MARGIN * 1.8;

        slide.addShape("roundRect" as unknown as PptxGenJS.ShapeType, {
          x: panelX,
          y: panelY,
          w: panelW,
          h: panelH,
          fill: {
            color: theme.overlayColor,
            transparency: transparencyFromOpacity(theme.overlayOpacity),
          },
          line: { color: theme.overlayColor, transparency: 80 },
        });

        let yOffset = panelY + 0.25;

        if (sc.sectionLabel) {
          slide.addText(sc.sectionLabel, {
            x: panelX,
            y: yOffset,
            w: panelW,
            h: 0.4,
            fontSize: 14,
            fontFace: theme.fontFace,
            color: theme.accentColor,
            align: "center",
            italic: true,
            margin: 0,
          });
          yOffset += 0.55;
        }

        const lyricsText = (sc.lines ?? []).join("\n");
        slide.addText(lyricsText, {
          x: panelX,
          y: yOffset,
          w: panelW,
          h: panelY + panelH - yOffset - 0.25,
          fontSize: lyricsFontSize(theme.lyricsFontSize, settings.linesPerSlide),
          fontFace: theme.fontFace,
          color: theme.textColor,
          align: "center",
          valign: "middle",
          lineSpacingMultiple: 1.3,
          margin: 0,
        });
        break;
      }
    }
  }

  const output = await pres.write({ outputType: "nodebuffer" });
  return output as Buffer;
}
